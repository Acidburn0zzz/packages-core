From 92e60ac7db324442f069a623a98ed1ee1540a626 Mon Sep 17 00:00:00 2001
From: Richard Yao <ryao@gentoo.org>
Date: Wed, 7 Aug 2013 08:53:45 -0400
Subject: [PATCH] Linux 3.11 compat: fops->iterate()

Commit torvalds/linux@2233f31aade393641f0eaed43a71110e629bb900 replaced
->readdir() with ->iterate() in struct file_operations.

Signed-off-by: Richard Yao <ryao@gentoo.org>
---
 config/kernel-vfs-iterate.m4 | 43 +++++++++++++++++++++++++
 config/kernel.m4             |  1 +
 include/sys/zfs_vnops.h      |  4 +++
 module/zfs/zfs_vnops.c       | 41 +++++++++++++++++------
 module/zfs/zpl_ctldir.c      | 77 +++++++++++++++++++++++++++++++++++++++++---
 module/zfs/zpl_file.c        | 13 ++++++++
 module/zfs/zpl_xattr.c       |  8 +++++
 7 files changed, 172 insertions(+), 15 deletions(-)
 create mode 100644 config/kernel-vfs-iterate.m4

diff --git a/config/kernel-vfs-iterate.m4 b/config/kernel-vfs-iterate.m4
new file mode 100644
index 0000000..c2c6562
--- /dev/null
+++ b/config/kernel-vfs-iterate.m4
@@ -0,0 +1,43 @@
+dnl #
+dnl # 3.11 API change
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_VFS_ITERATE], [
+	AC_MSG_CHECKING([whether fops->iterate() is available])
+	ZFS_LINUX_TRY_COMPILE([
+		#include <linux/fs.h>
+		int iterate(struct file *filp, struct dir_context * context)
+		    { return 0; }
+
+		static const struct file_operations fops
+		    __attribute__ ((unused)) = {
+			.iterate	 = iterate,
+		};
+	],[
+	],[
+		AC_MSG_RESULT(yes)
+		AC_DEFINE(HAVE_VFS_ITERATE, 1,
+		          [fops->iterate() is available])
+	],[
+		AC_MSG_RESULT(no)
+
+		AC_MSG_CHECKING([whether fops->readdir() is available])
+		ZFS_LINUX_TRY_COMPILE([
+			#include <linux/fs.h>
+			int readdir(struct file *filp, void *entry, filldir_t func)
+			    { return 0; }
+
+			static const struct file_operations fops
+			    __attribute__ ((unused)) = {
+				.readdir = readdir,
+			};
+		],[
+		],[
+			AC_MSG_RESULT(yes)
+			AC_DEFINE(HAVE_VFS_READDIR, 1,
+				  [fops->readdir() is available])
+		],[
+			AC_MSG_ERROR(no; file a bug report with ZFSOnLinux)
+		])
+
+	])
+])
diff --git a/config/kernel.m4 b/config/kernel.m4
index 8742bc5..74ce22c 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -80,6 +80,7 @@ AC_DEFUN([ZFS_AC_CONFIG_KERNEL], [
 	ZFS_AC_KERNEL_ELEVATOR_CHANGE
 	ZFS_AC_KERNEL_5ARG_SGET
 	ZFS_AC_KERNEL_LSEEK_EXECUTE
+	ZFS_AC_KERNEL_VFS_ITERATE
 
 	AS_IF([test "$LINUX_OBJ" != "$LINUX"], [
 		KERNELMAKE_PARAMS="$KERNELMAKE_PARAMS O=$LINUX_OBJ"
diff --git a/include/sys/zfs_vnops.h b/include/sys/zfs_vnops.h
index 75f7c12..0bb077f 100644
--- a/include/sys/zfs_vnops.h
+++ b/include/sys/zfs_vnops.h
@@ -51,8 +51,12 @@ extern int zfs_mkdir(struct inode *dip, char *dirname, vattr_t *vap,
     struct inode **ipp, cred_t *cr, int flags, vsecattr_t *vsecp);
 extern int zfs_rmdir(struct inode *dip, char *name, struct inode *cwd,
     cred_t *cr, int flags);
+#ifdef HAVE_VFS_ITERATE
+extern int zfs_readdir(struct inode *ip, struct dir_context *ctx);
+#else
 extern int zfs_readdir(struct inode *ip, void *dirent, filldir_t filldir,
     loff_t *pos, cred_t *cr);
+#endif
 extern int zfs_fsync(struct inode *ip, int syncflag, cred_t *cr);
 extern int zfs_getattr(struct inode *ip, vattr_t *vap, int flag, cred_t *cr);
 extern int zfs_getattr_fast(struct inode *ip, struct kstat *sp);
diff --git a/module/zfs/zfs_vnops.c b/module/zfs/zfs_vnops.c
index db5d385..7c89648 100644
--- a/module/zfs/zfs_vnops.c
+++ b/module/zfs/zfs_vnops.c
@@ -1997,8 +1997,12 @@
  */
 /* ARGSUSED */
 int
+#ifdef HAVE_VFS_ITERATE
+zfs_readdir(struct inode *ip, struct dir_context *ctx)
+#else
 zfs_readdir(struct inode *ip, void *dirent, filldir_t filldir,
     loff_t *pos, cred_t *cr)
+#endif
 {
 	znode_t		*zp = ITOZ(ip);
 	zfs_sb_t	*zsb = ITOZSB(ip);
@@ -2010,6 +2014,11 @@
 	uint8_t		prefetch;
 	int		done = 0;
 	uint64_t	parent;
+#ifdef HAVE_VFS_ITERATE
+	loff_t		offset = ctx->pos;
+#else
+	loff_t		offset = *pos;
+#endif
 
 	ZFS_ENTER(zsb);
 	ZFS_VERIFY_ZP(zp);
@@ -2031,7 +2040,7 @@
 	/*
 	 * Initialize the iterator cursor.
 	 */
-	if (*pos <= 3) {
+	if (offset <= 3) {
 		/*
 		 * Start iteration from the beginning of the directory.
 		 */
@@ -2040,7 +2049,7 @@
 		/*
 		 * The offset is a serialized cursor.
 		 */
-		zap_cursor_init_serialized(&zc, os, zp->z_id, *pos);
+		zap_cursor_init_serialized(&zc, os, zp->z_id, offset);
 	}
 
 	/*
@@ -2053,15 +2062,15 @@
 		/*
 		 * Special case `.', `..', and `.zfs'.
 		 */
-		if (*pos == 0) {
+		if (offset == 0) {
 			(void) strcpy(zap.za_name, ".");
 			zap.za_normalization_conflict = 0;
 			objnum = zp->z_id;
-		} else if (*pos == 1) {
+		} else if (offset == 1) {
 			(void) strcpy(zap.za_name, "..");
 			zap.za_normalization_conflict = 0;
 			objnum = parent;
-		} else if (*pos == 2 && zfs_show_ctldir(zp)) {
+		} else if (offset == 2 && zfs_show_ctldir(zp)) {
 			(void) strcpy(zap.za_name, ZFS_CTLDIR_NAME);
 			zap.za_normalization_conflict = 0;
 			objnum = ZFSCTL_INO_ROOT;
@@ -2089,7 +2098,7 @@
 				    "entry, obj = %lld, offset = %lld, "
 				    "length = %d, num = %lld\n",
 				    (u_longlong_t)zp->z_id,
-				    (u_longlong_t)*pos,
+				    (u_longlong_t)offset,
 				    zap.za_integer_length,
 				    (u_longlong_t)zap.za_num_integers);
 				error = ENXIO;
@@ -2098,23 +2107,35 @@
 
 			objnum = ZFS_DIRENT_OBJ(zap.za_first_integer);
 		}
+
+#ifdef HAVE_VFS_ITERATE
+		if (!dir_emit(ctx, zap.za_name, strlen(zap.za_name),
+			objnum, ZFS_DIRENT_TYPE(zap.za_first_integer)))
+			break;
+#else
 		done = filldir(dirent, zap.za_name, strlen(zap.za_name),
-			       *pos, objnum, ZFS_DIRENT_TYPE(zap.za_first_integer));
+			       offset, objnum, ZFS_DIRENT_TYPE(zap.za_first_integer));
 		if (done) {
 			break;
 		}
+#endif
 
 		/* Prefetch znode */
 		if (prefetch) {
 			dmu_prefetch(os, objnum, 0, 0);
 		}
 
-		if (*pos > 2 || (*pos == 2 && !zfs_show_ctldir(zp))) {
+		if (offset > 2 || (offset == 2 && !zfs_show_ctldir(zp))) {
 			zap_cursor_advance(&zc);
-			*pos = zap_cursor_serialize(&zc);
+			offset = zap_cursor_serialize(&zc);
 		} else {
-			(*pos)++;
+			offset++;
 		}
+#ifdef HAVE_VFS_ITERATE
+		ctx->pos = offset;
+#else
+		*pos = offset;
+#endif
 	}
 	zp->z_zn_prefetch = B_FALSE; /* a lookup will re-enable pre-fetching */
 
diff --git a/module/zfs/zpl_ctldir.c b/module/zfs/zpl_ctldir.c
index 0897017..2fdbc49 100644
--- a/module/zfs/zpl_ctldir.c
+++ b/module/zfs/zpl_ctldir.c
@@ -46,6 +46,7 @@
 	return generic_file_open(ip, filp);
 }
 
+#ifndef HAVE_VFS_ITERATE
 static int
 zpl_common_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
@@ -74,34 +75,46 @@
 
 	return (error);
 }
+#endif
 
 /*
  * Get root directory contents.
  */
 static int
+#ifdef HAVE_VFS_ITERATE
+zpl_root_readdir(struct file *filp, struct dir_context *ctx)
+#else
 zpl_root_readdir(struct file *filp, void *dirent, filldir_t filldir)
+#endif
 {
 	struct dentry *dentry = filp->f_path.dentry;
 	struct inode *ip = dentry->d_inode;
 	zfs_sb_t *zsb = ITOZSB(ip);
 	int error = 0;
+#ifdef HAVE_VFS_ITERATE
+	filldir_t filldir = ctx->actor;
+	struct dir_context *dirent = ctx;
+	loff_t offset = ctx->pos;
+#else
+	loff_t offset = filp->f_pos;
+#endif
 
 	ZFS_ENTER(zsb);
 
-	switch (filp->f_pos) {
+	switch (offset) {
 	case 0:
 		error = filldir(dirent, ".", 1, 0, ip->i_ino, DT_DIR);
 		if (error)
 			goto out;
 
-		filp->f_pos++;
+		offset++;
 		/* fall-thru */
 	case 1:
 		error = filldir(dirent, "..", 2, 1, parent_ino(dentry), DT_DIR);
 		if (error)
 			goto out;
 
-		filp->f_pos++;
+		offset++;
 		/* fall-thru */
 	case 2:
 		error = filldir(dirent, ZFS_SNAPDIR_NAME,
@@ -109,7 +122,7 @@
 		if (error)
 			goto out;
 
-		filp->f_pos++;
+		offset++;
 		/* fall-thru */
 	case 3:
 		error = filldir(dirent, ZFS_SHAREDIR_NAME,
@@ -117,10 +130,15 @@
 		if (error)
 			goto out;
 
-		filp->f_pos++;
+		offset++;
 		/* fall-thru */
 	}
 out:
+#ifdef HAVE_VFS_ITERATE
+	ctx->pos = offset;
+#else
+	filp->f_pos = offset;
+#endif
 	ZFS_EXIT(zsb);
 
 	return (error);
@@ -175,7 +193,11 @@
 	.open		= zpl_common_open,
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
+#ifdef HAVE_VFS_ITERATE
+	.iterate	= zpl_root_readdir,
+#else
 	.readdir	= zpl_root_readdir,
+#endif
 };
 
 const struct inode_operations zpl_ops_root = {
@@ -275,7 +297,11 @@
 
 /* ARGSUSED */
 static int
+#ifdef HAVE_VFS_ITERATE
+zpl_snapdir_readdir(struct file *filp, struct dir_context *ctx)
+#else
 zpl_snapdir_readdir(struct file *filp, void *dirent, filldir_t filldir)
+#endif
 {
 	struct dentry *dentry = filp->f_path.dentry;
 	struct inode *dip = dentry->d_inode;
@@ -287,6 +313,24 @@
 
 	ZFS_ENTER(zsb);
 
+#ifdef HAVE_VFS_ITERATE
+	if (!dir_emit_dots(filp, ctx))
+		goto out;
+	cookie = ctx->pos;
+
+	while (error == 0) {
+		error = -dmu_snapshot_list_next(zsb->z_os, MAXNAMELEN,
+		    snapname, &id, &cookie, &case_conflict);
+		if (error)
+			goto out;
+
+		if (!dir_emit(ctx, snapname, strlen(snapname),
+			ZFSCTL_INO_SHARES - id, DT_DIR))
+			goto out;
+
+		ctx->pos = cookie;
+	}
+#else
 	cookie = filp->f_pos;
 	switch (filp->f_pos) {
 	case 0:
@@ -318,6 +362,7 @@
 			filp->f_pos = cookie;
 		}
 	}
+#endif
 out:
 	ZFS_EXIT(zsb);
 
@@ -413,7 +458,12 @@
 	.open		= zpl_common_open,
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
+#ifdef HAVE_VFS_ITERATE
+	.iterate	= zpl_snapdir_readdir,
+#else
 	.readdir	= zpl_snapdir_readdir,
+#endif
+
 };
 
 /*
@@ -460,7 +510,11 @@
 
 /* ARGSUSED */
 static int
+#ifdef HAVE_VFS_ITERATE
+zpl_shares_readdir(struct file *filp, struct dir_context *ctx)
+#else
 zpl_shares_readdir(struct file *filp, void *dirent, filldir_t filldir)
+#endif
 {
 	cred_t *cr = CRED();
 	struct dentry *dentry = filp->f_path.dentry;
@@ -472,7 +526,11 @@
 	ZFS_ENTER(zsb);
 
 	if (zsb->z_shares_dir == 0) {
+#ifdef HAVE_VFS_ITERATE
+		error = (dir_emit_dots(filp, ctx)) ? 0 : -EINVAL;
+#else
 		error = zpl_common_readdir(filp, dirent, filldir);
+#endif
 		ZFS_EXIT(zsb);
 		return (error);
 	}
@@ -484,7 +542,11 @@
 	}
 
 	crhold(cr);
+#ifdef HAVE_VFS_ITERATE
+	error = -zfs_readdir(ZTOI(dzp), ctx);
+#else
 	error = -zfs_readdir(ZTOI(dzp), dirent, filldir, &filp->f_pos, cr);
+#endif
 	crfree(cr);
 
 	iput(ZTOI(dzp));
@@ -532,7 +594,12 @@
 	.open		= zpl_common_open,
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
+#ifdef HAVE_VFS_ITERATE
+	.iterate	= zpl_shares_readdir,
+#else
 	.readdir	= zpl_shares_readdir,
+#endif
+
 };
 
 /*
diff --git a/module/zfs/zpl_file.c b/module/zfs/zpl_file.c
index 2995891..3501e75 100644
--- a/module/zfs/zpl_file.c
+++ b/module/zfs/zpl_file.c
@@ -64,15 +64,24 @@
 }
 
 static int
+#ifdef HAVE_VFS_ITERATE
+zpl_readdir(struct file *filp, struct dir_context *ctx)
+#else
 zpl_readdir(struct file *filp, void *dirent, filldir_t filldir)
+#endif
 {
+
 	struct dentry *dentry = filp->f_path.dentry;
 	cred_t *cr = CRED();
 	int error;
 
 	crhold(cr);
+#ifdef HAVE_VFS_ITERATE
+	error = -zfs_readdir(dentry->d_inode, ctx);
+#else
 	error = -zfs_readdir(dentry->d_inode, dirent, filldir,
 	    &filp->f_pos, cr);
+#endif
 	crfree(cr);
 	ASSERT3S(error, <=, 0);
 
@@ -506,7 +515,11 @@
 const struct file_operations zpl_dir_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= generic_read_dir,
+#ifdef HAVE_VFS_ITERATE
+	.iterate	= zpl_readdir,
+#else
 	.readdir	= zpl_readdir,
+#endif
 	.fsync		= zpl_fsync,
 	.unlocked_ioctl = zpl_ioctl,
 #ifdef CONFIG_COMPAT
diff --git a/module/zfs/zpl_xattr.c b/module/zfs/zpl_xattr.c
index eb2c00d..ff0cd90 100644
--- a/module/zfs/zpl_xattr.c
+++ b/module/zfs/zpl_xattr.c
@@ -123,7 +123,11 @@
 {
 	struct inode *ip = xf->inode;
 	struct inode *dxip = NULL;
+#ifdef HAVE_VFS_ITERATE
+	struct dir_context ctx = { .actor = zpl_xattr_filldir, .pos = 3 };
+#else
 	loff_t pos = 3;  /* skip '.', '..', and '.zfs' entries. */
+#endif
 	int error;
 
 	/* Lookup the xattr directory */
@@ -136,7 +140,11 @@
 	}
 
 	/* Fill provided buffer via zpl_zattr_filldir helper */
+#ifdef HAVE_VFS_ITERATE
+	error = -zfs_readdir(dxip, &ctx);
+#else
 	error = -zfs_readdir(dxip, (void *)xf, zpl_xattr_filldir, &pos, cr);
+#endif
 	iput(dxip);
 
 	return (error);
-- 
1.8.1.6

